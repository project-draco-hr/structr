{
  Long transactionKeyValue=transactionKeyMap.get();
  if (transactionKeyValue == null) {
    return -1L;
  }
  long transactionKey=transactionKeyMap.get();
  if (!Services.isReady(NodeService.class)) {
    logger.log(Level.WARNING,"Node service is not ready yet.");
    return transactionKey;
  }
  SecurityContext securityContext=securityContextMap.get();
  SecurityContext superUserContext=SecurityContext.getSuperUserInstance();
  NewIndexNodeCommand indexNodeCommand=Services.command(superUserContext,NewIndexNodeCommand.class);
  IndexRelationshipCommand indexRelationshipCommand=Services.command(superUserContext,IndexRelationshipCommand.class);
  try {
    Map<Relationship,Map<String,Object>> removedRelProperties=new LinkedHashMap<Relationship,Map<String,Object>>();
    Map<Node,Map<String,Object>> removedNodeProperties=new LinkedHashMap<Node,Map<String,Object>>();
    RelationshipFactory relFactory=new RelationshipFactory(securityContext);
    TransactionChangeSet changeSet=new TransactionChangeSet();
    ErrorBuffer errorBuffer=new ErrorBuffer();
    NodeFactory nodeFactory=new NodeFactory(securityContext);
    boolean hasError=false;
    globalChangeSets.put(transactionKey,changeSet);
    for (    StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
      listener.begin(securityContext,transactionKey);
    }
    hasError|=collectRemovedNodeProperties(securityContext,transactionKey,errorBuffer,data,changeSet,nodeFactory,removedNodeProperties);
    hasError|=collectRemovedRelationshipProperties(securityContext,transactionKey,errorBuffer,data,changeSet,relFactory,removedRelProperties);
    hasError|=callOnNodeCreation(securityContext,transactionKey,errorBuffer,data,changeSet,nodeFactory);
    hasError|=callOnRelationshipCreation(securityContext,transactionKey,errorBuffer,data,changeSet,relFactory,nodeFactory);
    hasError|=callOnRelationshipDeletion(securityContext,transactionKey,errorBuffer,data,changeSet,relFactory,nodeFactory,removedRelProperties);
    hasError|=callOnNodeDeletion(securityContext,transactionKey,errorBuffer,data,changeSet,nodeFactory,removedNodeProperties);
    hasError|=callNodeValidators(securityContext,transactionKey,errorBuffer,data,changeSet,nodeFactory);
    hasError|=callRelationshipValidators(securityContext,transactionKey,errorBuffer,data,changeSet,relFactory);
    hasError|=callOnNodeModification(securityContext,transactionKey,errorBuffer,changeSet,indexNodeCommand);
    hasError|=callOnRelationshipModification(securityContext,transactionKey,errorBuffer,changeSet,indexRelationshipCommand);
    for (    AbstractNode node : changeSet.getCreatedNodes()) {
      indexNodeCommand.addNode(node);
    }
    for (    AbstractRelationship rel : changeSet.getCreatedRelationships()) {
      indexRelationshipCommand.execute(rel);
    }
    if (hasError) {
      for (      StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
        listener.rollback(securityContext,transactionKey);
      }
      throw new FrameworkException(422,errorBuffer);
    }
    for (    StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
      listener.commit(securityContext,transactionKey);
    }
  }
 catch (  FrameworkException fex) {
    exceptionMap.put(transactionKey,fex);
    throw new IllegalStateException("Rollback");
  }
  return transactionKey;
}
