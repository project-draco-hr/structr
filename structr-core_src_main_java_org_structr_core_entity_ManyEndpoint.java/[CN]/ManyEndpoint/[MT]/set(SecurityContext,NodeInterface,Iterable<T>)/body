{
  final Set<T> toBeDeleted=new LinkedHashSet<>(Iterables.toList(get(securityContext,sourceNode)));
  final Set<T> toBeCreated=new LinkedHashSet<>();
  if (collection != null) {
    Iterables.addAll(toBeCreated,collection);
  }
  final Set<T> intersection=new LinkedHashSet<>(toBeCreated);
  intersection.retainAll(toBeDeleted);
  toBeCreated.removeAll(intersection);
  toBeDeleted.removeAll(intersection);
  Services.command(securityContext,TransactionCommand.class).execute(new StructrTransaction(){
    @Override public Object execute() throws FrameworkException {
      final CreateRelationshipCommand create=Services.command(securityContext,CreateRelationshipCommand.class);
      final DeleteRelationshipCommand delete=Services.command(securityContext,DeleteRelationshipCommand.class);
      for (      T targetNode : toBeDeleted) {
        for (        AbstractRelationship rel : sourceNode.getOutgoingRelationships()) {
          if (rel.getRelType().equals(relation.getRelationshipType()) && rel.getTargetNode().equals(targetNode)) {
            delete.execute(rel);
          }
        }
      }
      for (      T targetNode : toBeCreated) {
        relation.checkMultiplicity(sourceNode,targetNode);
        create.execute(sourceNode,targetNode,relation.getClass());
      }
      return null;
    }
  }
);
}
