{
  if (!deletedNodes.contains(node) && node.getUuid() == null) {
    logger.log(Level.WARNING,"Will not delete node which has no UUID");
    return null;
  }
  deletedNodes.add(node);
  final DeleteRelationshipCommand deleteRel=Services.command(securityContext,DeleteRelationshipCommand.class);
  Services.command(securityContext,TransactionCommand.class).execute(new StructrTransaction(){
    @Override public Object execute() throws FrameworkException {
      try {
        List<NodeInterface> nodesToCheckAfterDeletion=new LinkedList<>();
        if (cascade) {
          for (          AbstractRelationship rel : node.getOutgoingRelationships()) {
            int cascadeDelete=rel.cascadeDelete();
            NodeInterface endNode=rel.getEndNode();
            if ((cascadeDelete & Relation.DELETE_IF_CONSTRAINT_WOULD_BE_VIOLATED) == Relation.DELETE_IF_CONSTRAINT_WOULD_BE_VIOLATED) {
              nodesToCheckAfterDeletion.add(endNode);
            }
            if (!deletedNodes.contains(endNode) && ((cascadeDelete & Relation.DELETE_OUTGOING) == Relation.DELETE_OUTGOING)) {
              endNode.removeFromIndex();
              doDeleteNode(endNode,cascade);
            }
          }
          for (          AbstractRelationship rel : node.getIncomingRelationships()) {
            int cascadeDelete=rel.cascadeDelete();
            NodeInterface startNode=rel.getStartNode();
            if ((cascadeDelete & Relation.DELETE_IF_CONSTRAINT_WOULD_BE_VIOLATED) == Relation.DELETE_IF_CONSTRAINT_WOULD_BE_VIOLATED) {
              nodesToCheckAfterDeletion.add(startNode);
            }
            if (!deletedNodes.contains(startNode) && ((cascadeDelete & Relation.DELETE_INCOMING) == Relation.DELETE_INCOMING)) {
              startNode.removeFromIndex();
              doDeleteNode(startNode,cascade);
            }
          }
        }
        node.onNodeDeletion();
        for (        AbstractRelationship r : node.getRelationships()) {
          deleteRel.execute(r,true);
        }
        node.removeFromIndex();
        node.getNode().delete();
        TransactionCommand.nodeDeleted(node);
        if (cascade) {
          for (          NodeInterface nodeToCheck : nodesToCheckAfterDeletion) {
            ErrorBuffer errorBuffer=new ErrorBuffer();
            if (!deletedNodes.contains(nodeToCheck) && !nodeToCheck.isValid(errorBuffer)) {
              nodeToCheck.removeFromIndex();
              doDeleteNode(nodeToCheck,cascade);
            }
          }
        }
      }
 catch (      Throwable t) {
        logger.log(Level.WARNING,"Exception while deleting node: {0}",t);
      }
      return null;
    }
  }
);
  return null;
}
