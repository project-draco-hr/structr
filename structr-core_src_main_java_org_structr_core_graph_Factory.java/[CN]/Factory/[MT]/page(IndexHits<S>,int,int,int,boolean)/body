{
  final AtomicBoolean keepRunning=new AtomicBoolean(true);
  final AtomicInteger overallCount=new AtomicInteger();
  final AtomicInteger processedItems=new AtomicInteger();
  if (dontCheckCount) {
    overallCount.set(input.size());
    final PagingIterator<S> neoResult=new PagingIterator<>(input.iterator(),pageSize);
    final List<T> nodes=new LinkedList<>();
    try {
      neoResult.page(offset);
    }
 catch (    NoSuchElementException nex) {
      return new Result(Collections.emptyList(),overallCount.get(),true,false);
    }
    Iterator<S> resultPage=neoResult.nextPage();
    while (resultPage.hasNext()) {
      final S s=resultPage.next();
      final T t=(T)instantiate(s);
      if (t != null) {
        nodes.add(t);
      }
    }
    return new Result(nodes,overallCount.get(),true,false);
  }
 else {
    final List<Item<T>> nodes=new LinkedList<>();
    try (final IndexHits<S> closeable=input){
      final SecurityContext securityContext=factoryProfile.getSecurityContext();
      final boolean preventFullCount=securityContext.hasParameter("ignoreResultCount");
      final ConcurrentLinkedQueue<Item<S>> queue=new ConcurrentLinkedQueue<>();
      final List<Future> futures=new LinkedList<>();
      int threadCount=1;
      int rawCount=0;
      for (      final S item : closeable) {
        queue.add(new Item<>(rawCount++,item));
      }
      if (rawCount < 100) {
        final InstantiationWorker worker=new InstantiationWorker(securityContext,queue,nodes,offset,pageSize,dontCheckCount || preventFullCount);
        worker.setProcessedItems(processedItems);
        worker.setOverallCount(overallCount);
        worker.setKeepRunning(keepRunning);
        worker.doRun();
      }
 else {
        logger.log(Level.INFO,"Fetched {0} elements for instantiation",rawCount);
        final long t0=System.currentTimeMillis();
        threadCount=8;
        for (int i=0; i < threadCount; i++) {
          final InstantiationWorker worker=new InstantiationWorker(securityContext,queue,nodes,offset,pageSize,dontCheckCount || preventFullCount);
          worker.setProcessedItems(processedItems);
          worker.setOverallCount(overallCount);
          worker.setKeepRunning(keepRunning);
          futures.add(service.submit(worker));
        }
        for (        final Future future : futures) {
          try {
            future.get();
          }
 catch (          InterruptedException|ExecutionException iex) {
            iex.printStackTrace();
          }
        }
        final long t1=System.currentTimeMillis();
        logger.log(Level.INFO,"Instantiated {0} out of {1} elements in {2} s using {3} threads.",new Object[]{nodes.size(),rawCount,(t1 - t0) / 1000,threadCount});
      }
    }
     Collections.sort(nodes);
    final int size=nodes.size();
    final int from=Math.min(offset,size);
    final int to=Math.min(offset + pageSize,size);
    final List<T> output=new LinkedList<>();
    for (    final Item<T> item : nodes.subList(from,to)) {
      output.add(item.item);
    }
    return new Result(output,overallCount.get(),true,false);
  }
}
