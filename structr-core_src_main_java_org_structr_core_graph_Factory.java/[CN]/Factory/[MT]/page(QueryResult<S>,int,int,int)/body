{
  final AtomicBoolean keepRunning=new AtomicBoolean(true);
  final AtomicInteger overallCount=new AtomicInteger();
  final AtomicInteger processedItems=new AtomicInteger();
  final List<Item<T>> nodes=new LinkedList<>();
  try (final QueryResult<S> closeable=input){
    final SecurityContext securityContext=factoryProfile.getSecurityContext();
    final boolean preventFullCount=securityContext.hasParameter("ignoreResultCount");
    final ConcurrentLinkedQueue<Item<S>> queue=new ConcurrentLinkedQueue<>();
    final List<Future> futures=new LinkedList<>();
    int threadCount=1;
    int rawCount=0;
    for (    final S item : closeable) {
      queue.add(new Item<>(rawCount++,item));
    }
    if (rawCount < 100) {
      final InstantiationWorker worker=new InstantiationWorker(securityContext,queue,nodes,offset,pageSize,preventFullCount);
      worker.setProcessedItems(processedItems);
      worker.setOverallCount(overallCount);
      worker.setKeepRunning(keepRunning);
      worker.doRun();
    }
 else {
      final double t0=System.nanoTime();
      threadCount=8;
      for (int i=0; i < threadCount; i++) {
        final InstantiationWorker worker=new InstantiationWorker(securityContext,queue,nodes,offset,pageSize,preventFullCount);
        worker.setProcessedItems(processedItems);
        worker.setOverallCount(overallCount);
        worker.setKeepRunning(keepRunning);
        worker.pleaseLog(i == 0);
        futures.add(service.submit(worker));
      }
      for (      final Future future : futures) {
        try {
          future.get();
        }
 catch (        InterruptedException|ExecutionException iex) {
          iex.printStackTrace();
        }
      }
      final double t1=System.nanoTime();
      if (t1 - t0 > 1000000000) {
        logger.log(Level.INFO,"Instantiated {0} out of {1} elements in {2} s using {3} threads.",new Object[]{nodes.size(),rawCount,(t1 - t0) / 1000000000.0,threadCount});
      }
    }
  }
   Collections.sort(nodes);
  final int size=nodes.size();
  final int from=Math.min(offset,size);
  final int to=Math.min(offset + pageSize,size);
  final List<T> output=new LinkedList<>();
  for (  final Item<T> item : nodes.subList(from,to)) {
    output.add(item.item);
  }
  return new Result(output,overallCount.get(),true,false);
}
