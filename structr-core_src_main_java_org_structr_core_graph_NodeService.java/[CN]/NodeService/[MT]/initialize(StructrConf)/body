{
  final Map<String,String> neo4jConfiguration=new LinkedHashMap<>();
  final String basePath=config.getProperty(Services.BASE_PATH);
  final String dbPath=config.getProperty(Services.DATABASE_PATH);
  final String idName=GraphObject.id.dbName();
  logger.log(Level.INFO,"Initializing database ({0}) ...",dbPath);
  if (graphDb != null) {
    logger.log(Level.INFO,"Database already running ({0}) ...",dbPath);
    return;
  }
  if ("true".equals(config.getProperty(Services.NEO4J_SHELL_ENABLED,"false"))) {
    neo4jConfiguration.put(ShellSettings.remote_shell_enabled.name(),"true");
  }
  try {
    graphDb=new GraphDatabaseFactory().newEmbeddedDatabaseBuilder(dbPath).setConfig(neo4jConfiguration).loadPropertiesFromFile(dbPath + "/neo4j.conf").newGraphDatabase();
  }
 catch (  Throwable t) {
    logger.log(Level.INFO,"Database config {0}/neo4j.conf not found",dbPath);
    graphDb=new GraphDatabaseFactory().newEmbeddedDatabaseBuilder(dbPath).setConfig(neo4jConfiguration).newGraphDatabase();
  }
  if (graphDb == null) {
    logger.log(Level.SEVERE,"Database could not be started ({0}) ...",dbPath);
    return;
  }
  filesPath=config.getProperty(Services.FILES_PATH);
  File files=new File(filesPath);
  if (!files.exists()) {
    files.mkdir();
  }
  logger.log(Level.INFO,"Database ready.");
  logger.log(Level.FINE,"Initializing UUID index...");
  uuidIndex=graphDb.index().forNodes("uuidAllNodes",LuceneIndexImplementation.EXACT_CONFIG);
  nodeIndices.put(NodeIndex.uuid,uuidIndex);
  logger.log(Level.FINE,"UUID index ready.");
  logger.log(Level.FINE,"Initializing user index...");
  userIndex=graphDb.index().forNodes("nameEmailAllUsers",LuceneIndexImplementation.EXACT_CONFIG);
  nodeIndices.put(NodeIndex.user,userIndex);
  logger.log(Level.FINE,"Node Email index ready.");
  logger.log(Level.FINE,"Initializing exact email index...");
  caseInsensitiveUserIndex=graphDb.index().forNodes("caseInsensitiveAllUsers",MapUtil.stringMap("provider","lucene","type","exact","to_lower_case","true"));
  nodeIndices.put(NodeIndex.caseInsensitiveUser,caseInsensitiveUserIndex);
  logger.log(Level.FINE,"Node case insensitive node index ready.");
  logger.log(Level.FINE,"Initializing case insensitive fulltext node index...");
  fulltextIndex=graphDb.index().forNodes("fulltextAllNodes",LuceneIndexImplementation.FULLTEXT_CONFIG);
  nodeIndices.put(NodeIndex.fulltext,fulltextIndex);
  logger.log(Level.FINE,"Fulltext node index ready.");
  logger.log(Level.FINE,"Initializing keyword node index...");
  keywordIndex=graphDb.index().forNodes("keywordAllNodes",LuceneIndexImplementation.EXACT_CONFIG);
  nodeIndices.put(NodeIndex.keyword,keywordIndex);
  logger.log(Level.FINE,"Keyword node index ready.");
  logger.log(Level.FINE,"Initializing layer index...");
  final Map<String,String> spatialConfig=new HashMap<>();
  spatialConfig.put(LayerNodeIndex.LAT_PROPERTY_KEY,Location.latitude.dbName());
  spatialConfig.put(LayerNodeIndex.LON_PROPERTY_KEY,Location.longitude.dbName());
  spatialConfig.put(SpatialIndexProvider.GEOMETRY_TYPE,LayerNodeIndex.POINT_PARAMETER);
  layerIndex=new LayerNodeIndex("layerIndex",graphDb,spatialConfig);
  nodeIndices.put(NodeIndex.layer,layerIndex);
  logger.log(Level.FINE,"Layer index ready.");
  logger.log(Level.FINE,"Initializing node factory...");
  relUuidIndex=graphDb.index().forRelationships("uuidAllRelationships",LuceneIndexImplementation.EXACT_CONFIG);
  relIndices.put(RelationshipIndex.rel_uuid,relUuidIndex);
  logger.log(Level.FINE,"Relationship UUID index ready.");
  logger.log(Level.FINE,"Initializing relationship index...");
  relFulltextIndex=graphDb.index().forRelationships("fulltextAllRelationships",LuceneIndexImplementation.FULLTEXT_CONFIG);
  relIndices.put(RelationshipIndex.rel_fulltext,relFulltextIndex);
  logger.log(Level.FINE,"Relationship fulltext index ready.");
  logger.log(Level.FINE,"Initializing keyword relationship index...");
  relKeywordIndex=graphDb.index().forRelationships("keywordAllRelationships",LuceneIndexImplementation.EXACT_CONFIG);
  relIndices.put(RelationshipIndex.rel_keyword,relKeywordIndex);
  logger.log(Level.FINE,"Relationship numeric index ready.");
  logger.log(Level.FINE,"Initializing relationship factory...");
  logger.log(Level.FINE,"Relationship factory ready.");
  cypherExecutionEngine=new ExecutionEngine(graphDb);
  logger.log(Level.FINE,"Cypher execution engine ready.");
  if ("true".equals(config.getProperty(MIGRATION_KEY))) {
    final Iterator<Node> allNodes=GlobalGraphOperations.at(graphDb).getAllNodes().iterator();
    final int txLimit=1000;
    int count=1;
    logger.log(Level.INFO,"Migration of ID properties from uuid to id requested.");
    while (allNodes.hasNext()) {
      final Transaction tx=graphDb.beginTx();
      try {
        while (allNodes.hasNext()) {
          final Node node=allNodes.next();
          if (node.hasProperty("uuid")) {
            try {
              node.setProperty(idName,node.getProperty("uuid"));
              node.removeProperty("uuid");
              count++;
            }
 catch (            Throwable t) {
              t.printStackTrace();
            }
          }
          if ((count % txLimit) == 0) {
            break;
          }
        }
        tx.success();
      }
 catch (      Throwable t) {
        tx.failure();
      }
 finally {
        tx.finish();
      }
    }
    if (count > 1) {
      logger.log(Level.INFO,"Migrated {0} nodes to new ID property.",count - 1);
    }
  }
  File seedFile=new File(basePath + "/" + INITIAL_SEED_FILE);
  if (seedFile.exists()) {
    final Iterator<Node> allNodes=GlobalGraphOperations.at(graphDb).getAllNodes().iterator();
    boolean hasApplicationNodes=false;
    while (allNodes.hasNext()) {
      if (allNodes.next().hasProperty(idName)) {
        hasApplicationNodes=true;
      }
    }
    if (!hasApplicationNodes) {
      logger.log(Level.INFO,"Found initial seed file and no application nodes, applying initial seed..");
      Map<String,Object> attributes=new LinkedHashMap<>();
      attributes.put("mode","import");
      attributes.put("validate","false");
      attributes.put("file",seedFile.getAbsoluteFile().getAbsolutePath());
      try {
        StructrApp.getInstance().command(SyncCommand.class).execute(attributes);
      }
 catch (      FrameworkException fex) {
        logger.log(Level.WARNING,"Unable to import initial seed file.",fex);
      }
    }
  }
  isInitialized=true;
}
