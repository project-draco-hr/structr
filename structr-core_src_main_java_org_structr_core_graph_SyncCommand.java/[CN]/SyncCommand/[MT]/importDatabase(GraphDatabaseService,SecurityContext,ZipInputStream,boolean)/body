{
  final App app=StructrApp.getInstance();
  final Value<Long> nodeCountValue=new StaticValue<>(0L);
  final Value<Long> relCountValue=new StaticValue<>(0L);
  double t0=System.nanoTime();
  try {
    Map<String,Node> uuidMap=new LinkedHashMap<>();
    List<Relationship> rels=new LinkedList<>();
    List<Node> nodes=new LinkedList<>();
    PropertyContainer currentObject=null;
    BufferedReader reader=null;
    String currentKey=null;
    boolean finished=false;
    long nodeCount=0;
    long relCount=0;
    try {
      app.beginTx();
      reader=new BufferedReader(new InputStreamReader(zis));
      do {
        try {
          reader.mark(4);
          String objectType=read(reader,1);
          if ("\n".equals(objectType)) {
            continue;
          }
          if ("N".equals(objectType)) {
            currentObject=graphDb.createNode();
            nodeCount++;
            nodes.add((Node)currentObject);
          }
 else           if ("R".equals(objectType)) {
            String startId=(String)deserialize(reader);
            String endId=(String)deserialize(reader);
            String relTypeName=(String)deserialize(reader);
            Node endNode=uuidMap.get(endId);
            Node startNode=uuidMap.get(startId);
            if (startNode != null && endNode != null) {
              RelationshipType relType=DynamicRelationshipType.withName(relTypeName);
              currentObject=startNode.createRelationshipTo(endNode,relType);
              rels.add((Relationship)currentObject);
            }
            relCount++;
          }
 else {
            reader.reset();
            if (currentKey == null) {
              currentKey=(String)deserialize(reader);
            }
 else {
              if (currentObject != null) {
                Object obj=deserialize(reader);
                if ("uuid".equals(currentKey) && currentObject instanceof Node) {
                  String uuid=(String)obj;
                  uuidMap.put(uuid,(Node)currentObject);
                }
                currentObject.setProperty(currentKey,obj);
                currentKey=null;
              }
 else {
                logger.log(Level.WARNING,"No current object to store property in.");
              }
            }
          }
        }
 catch (        EOFException eofex) {
          finished=true;
        }
      }
 while (!finished);
    }
 catch (    IOException ioex) {
    }
    logger.log(Level.INFO,"Imported {0} nodes and {1} rels, committing transaction..",new Object[]{nodeCount,relCount});
    nodeCountValue.set(securityContext,nodeCount);
    relCountValue.set(securityContext,relCount);
    RelationshipFactory relFactory=new RelationshipFactory(securityContext);
    NodeFactory nodeFactory=new NodeFactory(securityContext);
    for (    Node node : nodes) {
      NodeInterface entity=nodeFactory.instantiate(node);
      TransactionCommand.nodeCreated(entity);
      entity.addToIndex();
    }
    for (    Relationship rel : rels) {
      RelationshipInterface entity=relFactory.instantiate(rel);
      TransactionCommand.relationshipCreated(entity);
      entity.addToIndex();
    }
    app.commitTx();
  }
 catch (  FrameworkException fex) {
    fex.printStackTrace();
  }
 finally {
    app.finishTx();
  }
  double t1=System.nanoTime();
  double time=((t1 - t0) / 1000000000.0);
  DecimalFormat decimalFormat=new DecimalFormat("0.000000000",DecimalFormatSymbols.getInstance(Locale.ENGLISH));
  logger.log(Level.INFO,"Import done in {0} s",decimalFormat.format(time));
}
