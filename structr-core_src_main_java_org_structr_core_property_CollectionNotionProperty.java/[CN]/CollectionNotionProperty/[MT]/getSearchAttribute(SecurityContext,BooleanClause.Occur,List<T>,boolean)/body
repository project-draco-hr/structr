{
  SourceSearchAttribute attr=new SourceSearchAttribute(occur);
  Set<GraphObject> intersectionResult=new LinkedHashSet<>();
  EndNodes collectionProperty=(EndNodes)base;
  boolean alreadyAdded=false;
  try {
    if (searchValues != null && !searchValues.isEmpty()) {
      boolean allBlank=true;
      for (      T searchValue : searchValues) {
        if (StringUtils.isBlank(searchValue.toString())) {
          continue;
        }
 else {
          allBlank=false;
        }
        if (exactMatch) {
          Result<AbstractNode> result=Services.command(securityContext,SearchNodeCommand.class).execute(Search.andExactTypeAndSubtypes(base.relatedType(),exactMatch),Search.andExactProperty(securityContext,notion.getPrimaryPropertyKey(),searchValue));
          for (          AbstractNode node : result.getResults()) {
switch (occur) {
case MUST:
              if (!alreadyAdded) {
                alreadyAdded=true;
              }
 else {
              }
            break;
case SHOULD:
          break;
case MUST_NOT:
        break;
    }
  }
}
 else {
  Result<AbstractNode> result=Services.command(securityContext,SearchNodeCommand.class).execute(Search.andExactTypeAndSubtypes(base.relatedType(),exactMatch),Search.andProperty(securityContext,notion.getPrimaryPropertyKey(),searchValue));
  for (  AbstractNode node : result.getResults()) {
  }
}
}
if (allBlank) {
return new EmptySearchAttribute(this,Collections.emptyList());
}
 else {
attr.setResult(new LinkedList<>(intersectionResult));
}
}
 else {
return new EmptySearchAttribute(this,Collections.emptyList());
}
}
 catch (FrameworkException fex) {
fex.printStackTrace();
}
return attr;
}
