{
  SourceSearchAttribute attr=new SourceSearchAttribute(occur);
  Set<GraphObject> intersectionResult=new LinkedHashSet<>();
  boolean alreadyAdded=false;
  try {
    if (searchValue != null && !StringUtils.isBlank(searchValue.toString())) {
      if (exactMatch) {
        Result<AbstractNode> result=Services.command(securityContext,SearchNodeCommand.class).execute(Search.andExactTypeAndSubtypes(entityProperty.relatedType(),exactMatch),Search.andExactProperty(securityContext,notion.getPrimaryPropertyKey(),searchValue));
        for (        AbstractNode node : result.getResults()) {
switch (occur) {
case MUST:
            if (!alreadyAdded) {
              intersectionResult.addAll(entityProperty.getRelatedNodesReverse(securityContext,node,declaringClass));
              alreadyAdded=true;
            }
 else {
              intersectionResult.retainAll(entityProperty.getRelatedNodesReverse(securityContext,node,declaringClass));
            }
          break;
case SHOULD:
        intersectionResult.addAll(entityProperty.getRelatedNodesReverse(securityContext,node,declaringClass));
      break;
case MUST_NOT:
    break;
}
}
}
 else {
Result<AbstractNode> result=Services.command(securityContext,SearchNodeCommand.class).execute(Search.andExactTypeAndSubtypes(entityProperty.relatedType(),exactMatch),Search.andProperty(securityContext,notion.getPrimaryPropertyKey(),searchValue));
for (AbstractNode node : result.getResults()) {
intersectionResult.addAll(entityProperty.getRelatedNodesReverse(securityContext,node,declaringClass));
}
}
attr.setResult(new LinkedList<>(intersectionResult));
}
 else {
return new EmptySearchAttribute(this,null);
}
}
 catch (FrameworkException fex) {
fex.printStackTrace();
}
return attr;
}
