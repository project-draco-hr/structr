{
  final App app=StructrApp.getInstance();
  final NodeServiceCommand nodeServiceCommand=app.command(CreateNodeCommand.class);
  final GraphDatabaseService graphDb=app.command(GraphDatabaseCommand.class).execute();
  final ExecutionEngine engine=new ExecutionEngine(graphDb,new BufferingLogger());
  final Map<String,Map<String,Class>> properties=new LinkedHashMap<>();
  final Set<RelationshipTemplate> relationships=new LinkedHashSet<>();
  final Map<String,SchemaNode> schemaNodes=new LinkedHashMap<>();
  for (  final String source : sources) {
    engine.execute(source);
  }
  try (final Tx tx=app.tx()){
    TransactionCommand.postProcess("gist",app.command(BulkRebuildIndexCommand.class));
    for (    final Node node : Iterables.filter(new StructrAndSpatialPredicate(false,false,true),GlobalGraphOperations.at(graphDb).getAllNodes())) {
      String primaryType=getType(node);
      if (primaryType != null && !"ReferenceNode".equals(primaryType)) {
        for (        final String key : node.getPropertyKeys()) {
          final Object value=node.getProperty(key);
          if (value != null) {
            Map<String,Class> propertyTypes=properties.get(primaryType);
            if (propertyTypes == null) {
              propertyTypes=new LinkedHashMap<>();
              properties.put(primaryType,propertyTypes);
            }
            propertyTypes.put(key,value.getClass());
          }
        }
        node.setProperty(GraphObject.type.dbName(),primaryType);
        node.setProperty(GraphObject.id.dbName(),nodeServiceCommand.getNextUuid());
      }
    }
    for (    final Relationship rel : Iterables.filter(new StructrAndSpatialPredicate(false,false,true),GlobalGraphOperations.at(graphDb).getAllRelationships())) {
      final Node startNode=rel.getStartNode();
      final Node endNode=rel.getEndNode();
      final String relationshipType=rel.getType().name();
      final String startNodeType=getType(startNode);
      final String endNodeType=getType(endNode);
      final Set<String> typeSet=properties.keySet();
      if (typeSet.contains(startNodeType) && typeSet.contains(endNodeType)) {
        relationships.add(new RelationshipTemplate(startNodeType,endNodeType,relationshipType));
      }
      rel.setProperty(GraphObject.id.dbName(),nodeServiceCommand.getNextUuid());
    }
    for (    final Entry<String,Map<String,Class>> typeEntry : properties.entrySet()) {
      final String type=typeEntry.getKey();
      final Map<String,Class> props=typeEntry.getValue();
      final PropertyMap propertyMap=new PropertyMap();
      for (      final Entry<String,Class> propertyEntry : props.entrySet()) {
        propertyMap.put(new StringProperty("_".concat(propertyEntry.getKey())),propertyEntry.getValue().getSimpleName());
      }
      propertyMap.put(AbstractNode.name,type);
      schemaNodes.put(type,app.create(SchemaNode.class,propertyMap));
    }
    for (    final RelationshipTemplate template : relationships) {
      final SchemaNode startNode=schemaNodes.get(template.getStartNodeType());
      final SchemaNode endNode=schemaNodes.get(template.getEndNodeType());
      final String relationshipType=template.getRelType();
      final PropertyMap propertyMap=new PropertyMap();
      propertyMap.put(SchemaRelationship.sourceId,startNode.getUuid());
      propertyMap.put(SchemaRelationship.targetId,endNode.getUuid());
      propertyMap.put(SchemaRelationship.relationshipType,relationshipType);
      app.create(startNode,endNode,SchemaRelationship.class,propertyMap);
    }
    tx.success();
  }
   logger.log(Level.INFO,"Graph gist import successful, {0} types imported.",properties.size());
}
