{
  final HttpServletRequest request=securityContext.getRequest();
  if (request != null) {
    final String filesPath=Services.getInstance().getConfigurationValue(Services.FILES_PATH);
    final String subjectId=request.getParameter(subjectProperty.jsonName());
    final String objectId=request.getParameter(objectProperty.jsonName());
    final GraphObjectMap overviewMap=new GraphObjectMap();
    final LogState logState=new LogState(request);
    if (StringUtils.isNotEmpty(subjectId) && StringUtils.isNotEmpty(objectId)) {
      final String fileName=mergeIds(subjectId,objectId);
      final String path=getDirectoryPath(fileName,8);
      final Path filePath=new File(filesPath + SUBJECTS + path+ fileName).toPath();
      if (Files.exists(filePath)) {
        read(toMap(filePath,logState),logState);
      }
    }
 else     if (StringUtils.isNotEmpty(subjectId) && StringUtils.isEmpty(objectId)) {
      final String path=getDirectoryPath(subjectId,8);
      final Path directoryPath=new File(filesPath + SUBJECTS + path).toPath();
      try (final DirectoryStream<Path> stream=Files.newDirectoryStream(directoryPath,subjectId + "????????????????????????????????")){
        final Map<String,ArrayList<String>> fileLines=new LinkedHashMap<>();
        for (        final Path p : stream) {
          fileLines.putAll(toMap(p,logState));
        }
        read(fileLines,logState);
      }
 catch (      IOException ioex) {
        ioex.printStackTrace();
      }
    }
 else     if (StringUtils.isEmpty(subjectId) && StringUtils.isNotEmpty(objectId)) {
      logState.inverse(true);
      final String path=getDirectoryPath(objectId,8);
      final Path directoryPath=new File(filesPath + OBJECTS + path).toPath();
      try (final DirectoryStream<Path> stream=Files.newDirectoryStream(directoryPath,objectId + "????????????????????????????????")){
        final Map<String,ArrayList<String>> fileLines=new LinkedHashMap<>();
        for (        final Path p : stream) {
          fileLines.putAll(toMap(p,logState));
        }
        read(fileLines,logState);
      }
 catch (      IOException ioex) {
        ioex.printStackTrace();
      }
    }
 else     if (logState.doActionQuery()) {
      final Map<String,ArrayList<String>> fileLines=collectFiles(new File(filesPath + SUBJECTS).toPath(),logState);
      read(fileLines,logState);
    }
 else {
      logState.overview(true);
      final Map<String,ArrayList<String>> fileLines=collectFiles(new File(filesPath + SUBJECTS).toPath(),logState);
      read(fileLines,logState);
    }
    if (logState.overview()) {
      overviewMap.put(actionsProperty,logState.actions());
      overviewMap.put(entryCountProperty,logState.actionCount());
      overviewMap.put(firstEntryProperty,new Date(logState.beginTimestamp()));
      overviewMap.put(lastEntryProperty,new Date(logState.endTimestamp()));
      return new Result(overviewMap,false);
    }
 else     if (logState.doHistogram()) {
      return histogram(logState);
    }
 else     if (logState.doAggregate()) {
      return aggregate(logState);
    }
 else {
      logState.sortEntries();
      return new Result(wrap(logState.entries()),logState.size(),true,false);
    }
  }
  throw new FrameworkException(500,"No request object present, aborting.");
}
