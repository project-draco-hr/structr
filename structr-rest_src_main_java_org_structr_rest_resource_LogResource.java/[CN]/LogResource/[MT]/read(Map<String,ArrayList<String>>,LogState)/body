{
  for (  final String fileName : fileLines.keySet()) {
    final String pathSubjectId=state.inverse() ? fileName.substring(32,64) : fileName.substring(0,32);
    final String pathObjectId=state.inverse() ? fileName.substring(0,32) : fileName.substring(32,64);
    if (state.doCorrelate()) {
      for (      String line : fileLines.get(fileName)) {
        try {
          final int pos0=line.indexOf(",");
          final int pos1=line.indexOf(",",pos0 + 1);
          final String part0=line.substring(0,pos0);
          final String part1=line.substring(pos0 + 1,pos1);
          final String part2=line.substring(pos1 + 1);
          final String entryAction=part1;
          final String entryMessage=part2;
          if (state.isCorrelatedAction(entryAction)) {
            if (state.correlationPattern != null) {
              final Matcher matcher=state.correlationPattern.matcher(line);
              if (matcher.matches()) {
                state.addCorrelationEntry(matcher.group(1),entryMessage);
              }
            }
 else {
              state.addCorrelationEntry(key(pathSubjectId,pathObjectId),entryMessage);
            }
          }
        }
 catch (        Throwable t) {
          t.printStackTrace();
        }
      }
    }
  }
  logger.log(Level.FINE,"No. of correlations: {0}",state.getCorrelations().entrySet().size());
  for (  final String fileName : fileLines.keySet()) {
    final String pathSubjectId=state.inverse() ? fileName.substring(32,64) : fileName.substring(0,32);
    final String pathObjectId=state.inverse() ? fileName.substring(0,32) : fileName.substring(32,64);
    for (    String line : fileLines.get(fileName)) {
      try {
        final int pos0=line.indexOf(",");
        final int pos1=line.indexOf(",",pos0 + 1);
        final String part0=line.substring(0,pos0);
        final String part1=line.substring(pos0 + 1,pos1);
        final String part2=line.substring(pos1 + 1);
        final long timestamp=Long.valueOf(part0);
        final String entryAction=part1;
        final String entryMessage=part2;
        if (timestamp <= state.beginTimestamp()) {
          state.beginTimestamp(timestamp);
        }
        if (timestamp >= state.endTimestamp()) {
          state.endTimestamp(timestamp);
        }
        if (state.overview()) {
          state.countAction(entryAction);
        }
 else {
          if (state.isRequestedActionOrNull(entryAction)) {
            final Map<String,Object> map=new LinkedHashMap<>();
            map.put(subjectProperty.jsonName(),pathSubjectId);
            map.put(objectProperty.jsonName(),pathObjectId);
            map.put(actionProperty.jsonName(),entryAction);
            map.put(timestampProperty.jsonName(),timestamp);
            map.put(messageProperty.jsonName(),entryMessage);
            if (state.isInRangeOrNull(timestamp) && state.correlates(key(pathSubjectId,pathObjectId),entryMessage)) {
              state.addEntry(map);
            }
          }
        }
      }
 catch (      Throwable t) {
        t.printStackTrace();
      }
    }
  }
}
