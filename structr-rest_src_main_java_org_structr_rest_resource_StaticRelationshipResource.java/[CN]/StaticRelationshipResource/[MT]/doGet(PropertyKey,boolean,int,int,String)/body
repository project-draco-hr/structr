{
  final GraphObject sourceEntity=typedIdResource.getEntity();
  if (sourceEntity != null) {
    if (propertyKey == null) {
      if (sourceEntity instanceof NodeInterface) {
        if (!typeResource.isNode) {
          final NodeInterface source=(NodeInterface)sourceEntity;
          final Node sourceNode=source.getNode();
          final Class relationshipType=typeResource.entityClass;
          final Relation relation=AbstractNode.getRelationshipForType(relationshipType);
          final Class destNodeType=relation.getOtherType(typedIdResource.getEntityClass());
          final Set partialResult=new LinkedHashSet<>(typeResource.doGet(sortKey,sortDescending,NodeFactory.DEFAULT_PAGE_SIZE,NodeFactory.DEFAULT_PAGE,null).getResults());
          final Set<GraphObject> set=Iterables.toSet(Iterables.filter(new OtherNodeTypeRelationFilter(securityContext,sourceNode,destNodeType),source.getRelationships(relationshipType)));
          set.retainAll(partialResult);
          final List<GraphObject> finalResult=new LinkedList<>(set);
          applyDefaultSorting(finalResult,sortKey,sortDescending);
          return new Result(PagingHelper.subList(finalResult,pageSize,page,offsetId),finalResult.size(),isCollectionResource(),isPrimitiveArray());
        }
 else {
          throw new NotFoundException("Cannot access relationship collection " + typeResource.getRawType());
        }
      }
    }
 else {
      Query query=typeResource.query;
      if (query == null) {
        query=StructrApp.getInstance(securityContext).nodeQuery();
      }
      typeResource.collectSearchAttributes(query);
      final Predicate<GraphObject> predicate=query.toPredicate();
      final Object value=sourceEntity.getProperty(propertyKey,predicate);
      if (value != null) {
        if (value instanceof Iterable) {
          final Set<GraphObject> propertyResults=new LinkedHashSet<>();
          final Set<Object> rawPropertyResults=new LinkedHashSet<>();
          boolean iterableContainsGraphObject=false;
          Iterator<Object> iter=((Iterable<Object>)value).iterator();
          while (iter.hasNext()) {
            Object obj=iter.next();
            if (obj != null) {
              if (iterableContainsGraphObject) {
                propertyResults.add((GraphObject)obj);
              }
 else               if (!iterableContainsGraphObject) {
                if (obj instanceof GraphObject) {
                  iterableContainsGraphObject=true;
                  propertyResults.add((GraphObject)obj);
                }
 else {
                  rawPropertyResults.add(obj);
                }
              }
            }
          }
          if (rawPropertyResults.size() > 0) {
            GraphObjectMap gObject=new GraphObjectMap();
            gObject.setProperty(new ArrayProperty(this.typeResource.rawType,Object.class,new TypeValidator(Object.class)),rawPropertyResults.toArray());
            return new Result(gObject,true);
          }
          final List<GraphObject> finalResult=new LinkedList<>(propertyResults);
          applyDefaultSorting(finalResult,sortKey,sortDescending);
          return new Result(PagingHelper.subList(finalResult,pageSize,page,offsetId),finalResult.size(),isCollectionResource(),isPrimitiveArray());
        }
 else         if (value instanceof GraphObject) {
          return new Result((GraphObject)value,isPrimitiveArray());
        }
 else         if (value != null) {
          GraphObjectMap gObject=new GraphObjectMap();
          PropertyKey key;
          String keyName=this.typeResource.rawType;
          if (value instanceof String) {
            key=new StringProperty(keyName);
          }
 else           if (value instanceof Integer) {
            key=new IntProperty(keyName);
          }
 else           if (value instanceof Long) {
            key=new LongProperty(keyName);
          }
 else           if (value instanceof Double) {
            key=new DoubleProperty(keyName);
          }
 else           if (value instanceof Boolean) {
            key=new BooleanProperty(keyName);
          }
 else           if (value instanceof Date) {
            key=new DateProperty(keyName);
          }
 else           if (value instanceof String[]) {
            key=new ArrayProperty(keyName,String.class,new TypeValidator(String.class));
          }
 else {
            key=new StringProperty(keyName);
          }
          gObject.setProperty(key,value);
          return new Result(gObject,true);
        }
 else {
          logger.log(Level.INFO,"Found object {0}, but will not return as it is no graph object or iterable",value);
        }
      }
    }
  }
  return Result.EMPTY_RESULT;
}
