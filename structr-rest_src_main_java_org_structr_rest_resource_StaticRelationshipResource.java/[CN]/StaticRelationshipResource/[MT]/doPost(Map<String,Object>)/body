{
  final AbstractNode sourceNode=typedIdResource.getIdResource().getNode();
  final PropertyKey propertyKey=findPropertyKey(typedIdResource,typeResource);
  if (sourceNode != null && propertyKey != null && propertyKey instanceof AbstractRelationProperty) {
    final StructrTransaction transaction=new StructrTransaction(){
      @Override public Object execute() throws FrameworkException {
        final AbstractRelationProperty relationshipProperty=(AbstractRelationProperty)propertyKey;
        final Class sourceNodeType=sourceNode.getClass();
        if (relationshipProperty.isReadOnly()) {
          logger.log(Level.INFO,"Read-only property on {0}: {1}",new Object[]{sourceNodeType,typeResource.getRawType()});
          return null;
        }
        final Notion notion=relationshipProperty.getNotion();
        final PropertyKey primaryPropertyKey=notion.getPrimaryPropertyKey();
        if (primaryPropertyKey != null && propertySet.containsKey(primaryPropertyKey.jsonName()) && propertySet.size() == 1) {
          final Adapter<Object,GraphObject> deserializationStrategy=notion.getAdapterForSetter(securityContext);
          final Object keySource=propertySet.get(primaryPropertyKey.jsonName());
          if (keySource != null) {
            GraphObject otherNode=null;
            if (keySource instanceof Collection) {
              final Collection collection=(Collection)keySource;
              for (              final Object key : collection) {
                otherNode=deserializationStrategy.adapt(key);
                if (otherNode != null && otherNode instanceof AbstractNode) {
                  relationshipProperty.createRelationship(securityContext,sourceNode,(AbstractNode)otherNode);
                }
 else {
                  logger.log(Level.WARNING,"Relationship end node has invalid type {0}",otherNode.getClass().getName());
                }
              }
            }
 else {
              otherNode=deserializationStrategy.adapt(keySource);
              if (otherNode != null && otherNode instanceof AbstractNode) {
                relationshipProperty.createRelationship(securityContext,sourceNode,(AbstractNode)otherNode);
              }
 else {
                logger.log(Level.WARNING,"Relationship end node has invalid type {0}",otherNode.getClass().getName());
              }
            }
            return otherNode;
          }
 else {
            logger.log(Level.INFO,"Key {0} not found in {1}",new Object[]{primaryPropertyKey.jsonName(),propertySet.toString()});
          }
        }
 else {
          final AbstractNode otherNode=typeResource.createNode(propertySet);
          if (otherNode != null) {
            relationshipProperty.createRelationship(securityContext,sourceNode,otherNode);
            return otherNode;
          }
        }
        return null;
      }
    }
;
    AbstractNode newNode=(AbstractNode)Services.command(securityContext,TransactionCommand.class).execute(transaction);
    if (newNode != null) {
      RestMethodResult result=new RestMethodResult(HttpServletResponse.SC_CREATED);
      result.addHeader("Location",buildLocationHeader(newNode));
      return result;
    }
  }
 else {
    AbstractNode entity=typedIdResource.getTypesafeNode();
    Class entityType=typedIdResource.getEntityClass();
    String methodName=typeResource.getRawType();
    boolean success=false;
    if (entityType != null && methodName != null) {
      for (      Method method : EntityContext.getExportedMethodsForType(entityType)) {
        if (methodName.equals(method.getName())) {
          if (method.getAnnotation(Export.class) != null) {
            if (method.getReturnType().equals(Void.TYPE)) {
              try {
                Object[] parameters=extractParameters(propertySet,method.getParameterTypes());
                method.invoke(entity,parameters);
                success=true;
                break;
              }
 catch (              Throwable t) {
                logger.log(Level.WARNING,"Unable to call RPC method {0}: {1}",new Object[]{methodName,t.getMessage()});
              }
            }
 else {
              logger.log(Level.WARNING,"Unable to call RPC method {0}: method has wrong return type (must be void).",methodName);
            }
          }
        }
      }
    }
    if (success) {
      return new RestMethodResult(HttpServletResponse.SC_OK);
    }
  }
  throw new IllegalPathException();
}
