{
  try {
    final RelationshipDataContainer receivedRelationshipData=(RelationshipDataContainer)receivedData;
    final String sourceStartNodeId=receivedRelationshipData.getSourceStartNodeId();
    final String sourceEndNodeId=receivedRelationshipData.getSourceEndNodeId();
    final String uuid=receivedRelationshipData.getRelationshipId();
    final String targetStartNodeId=idMap.get(sourceStartNodeId);
    final String targetEndNodeId=idMap.get(sourceEndNodeId);
    if (targetStartNodeId != null && targetEndNodeId != null) {
      final NodeInterface targetStartNode=(NodeInterface)app.get(targetStartNodeId);
      final NodeInterface targetEndNode=(NodeInterface)app.get(targetEndNodeId);
      final Class relType=receivedRelationshipData.getType();
      final SecurityContext securityContext=SecurityContext.getSuperUserInstance();
      if (targetStartNode != null && targetEndNode != null) {
        final RelationshipInterface existingCandidate=app.relationshipQuery().and(GraphObject.id,uuid).includeDeletedAndHidden().getFirst();
        final PropertyMap properties=PropertyMap.databaseTypeToJavaType(securityContext,relType,receivedRelationshipData.getProperties());
        if (existingCandidate != null) {
          ((Syncable)existingCandidate).updateFromPropertyMap(properties);
          return existingCandidate;
        }
 else {
          return app.create(targetStartNode,targetEndNode,relType,properties);
        }
      }
    }
    logger.log(Level.WARNING,"Could not store relationship {0} -> {1}",new Object[]{sourceStartNodeId,sourceEndNodeId});
  }
 catch (  FrameworkException fex) {
    fex.printStackTrace();
  }
  return null;
}
