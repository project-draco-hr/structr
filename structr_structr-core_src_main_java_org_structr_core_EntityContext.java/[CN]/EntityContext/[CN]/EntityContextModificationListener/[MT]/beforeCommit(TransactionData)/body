{
  long transactionKey=transactionKeyMap.get(Thread.currentThread());
  try {
    Map<Node,Map<String,Object>> removedProperties=new LinkedHashMap<Node,Map<String,Object>>();
    SecurityContext securityContext=SecurityContext.getSuperUserInstance();
    StructrNodeFactory factory=new StructrNodeFactory(securityContext);
    Set<AbstractNode> modifiedNodes=new LinkedHashSet<AbstractNode>();
    Set<AbstractNode> createdNodes=new LinkedHashSet<AbstractNode>();
    Set<StructrRelationship> createdRels=new LinkedHashSet<StructrRelationship>();
    Set<StructrRelationship> deletedRels=new LinkedHashSet<StructrRelationship>();
    begin(securityContext,transactionKey);
    for (    PropertyEntry<Node> entry : data.removedNodeProperties()) {
      Node node=entry.entity();
      Map<String,Object> propertyMap=removedProperties.get(node);
      if (propertyMap == null) {
        propertyMap=new LinkedHashMap<String,Object>();
        removedProperties.put(node,propertyMap);
      }
      propertyMap.put(entry.key(),entry.previouslyCommitedValue());
    }
    for (    Node node : data.createdNodes()) {
      AbstractNode entity=factory.createNode(securityContext,node);
      graphObjectCreated(securityContext,transactionKey,entity);
      createdNodes.add(entity);
    }
    for (    Relationship rel : data.createdRelationships()) {
      StructrRelationship relationship=new StructrRelationship(securityContext,rel);
      relationshipCreated(securityContext,transactionKey,relationship);
      createdRels.add(relationship);
    }
    for (    Relationship rel : data.deletedRelationships()) {
      StructrRelationship relationship=new StructrRelationship(securityContext,rel);
      relationshipDeleted(securityContext,transactionKey,relationship);
      deletedRels.add(relationship);
    }
    for (    Node node : data.deletedNodes()) {
      graphObjectDeleted(securityContext,transactionKey,node.getId(),removedProperties.get(node));
    }
    for (    PropertyEntry<Node> entry : data.assignedNodeProperties()) {
      AbstractNode entity=factory.createNode(securityContext,entry.entity());
      String key=entry.key();
      Object value=entry.value();
      PropertyValidator validator=EntityContext.getPropertyValidator(securityContext,entity.getClass(),key);
      if (validator != null) {
        logger.log(Level.FINE,"Using validator of type {0} for property {1}",new Object[]{validator.getClass().getSimpleName(),key});
        Value parameter=EntityContext.getPropertyValidationParameter(entity.getClass(),key);
        ErrorBuffer errorBuffer=new ErrorBuffer();
        if (!validator.isValid(key,value,parameter,errorBuffer)) {
          throw new IllegalArgumentException(errorBuffer.toString());
        }
      }
      propertyModified(securityContext,transactionKey,entity,key,entry.previouslyCommitedValue(),value);
      Services.command(securityContext,IndexNodeCommand.class).execute(entity,key);
      modifiedNodes.add(entity);
    }
    for (    AbstractNode node : modifiedNodes) {
      if (!createdNodes.contains(node)) {
        graphObjectModified(securityContext,transactionKey,node);
      }
    }
    commit(securityContext,transactionKey);
  }
 catch (  Throwable t) {
    throwableMap.put(transactionKey,t);
    throw new IllegalStateException("Rollback");
  }
  return transactionKey;
}
