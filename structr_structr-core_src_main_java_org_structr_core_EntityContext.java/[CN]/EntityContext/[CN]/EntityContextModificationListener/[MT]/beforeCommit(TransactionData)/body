{
  Thread currentThread=Thread.currentThread();
  if (!transactionKeyMap.containsKey(currentThread)) {
    return -1L;
  }
  long transactionKey=transactionKeyMap.get(Thread.currentThread());
  if (!Services.isReady(NodeService.class)) {
    logger.log(Level.WARNING,"Node service is not ready yet.");
    return transactionKey;
  }
  SecurityContext securityContext=securityContextMap.get(currentThread);
  SecurityContext superUserContext=SecurityContext.getSuperUserInstance();
  Command indexNodeCommand=Services.command(superUserContext,IndexNodeCommand.class);
  Command indexRelationshipCommand=Services.command(superUserContext,IndexRelationshipCommand.class);
  try {
    Map<Relationship,Map<String,Object>> removedRelProperties=new LinkedHashMap<Relationship,Map<String,Object>>();
    Map<Node,Map<String,Object>> removedNodeProperties=new LinkedHashMap<Node,Map<String,Object>>();
    RelationshipFactory relFactory=new RelationshipFactory(securityContext);
    TransactionChangeSet changeSet=new TransactionChangeSet();
    ErrorBuffer errorBuffer=new ErrorBuffer();
    NodeFactory nodeFactory=new NodeFactory();
    boolean hasError=false;
    for (    StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
      listener.begin(securityContext,transactionKey);
    }
    for (    PropertyEntry<Node> entry : data.removedNodeProperties()) {
      Node node=entry.entity();
      Map<String,Object> propertyMap=removedNodeProperties.get(node);
      if (propertyMap == null) {
        propertyMap=new LinkedHashMap<String,Object>();
        removedNodeProperties.put(node,propertyMap);
      }
      propertyMap.put(entry.key(),entry.previouslyCommitedValue());
      if (!data.isDeleted(node)) {
        AbstractNode modifiedNode=nodeFactory.createNode(securityContext,node,true,false);
        if (modifiedNode != null) {
          changeSet.modify(modifiedNode);
          for (          StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
            hasError|=!listener.propertyRemoved(securityContext,transactionKey,errorBuffer,modifiedNode,entry.key(),entry.previouslyCommitedValue());
          }
        }
      }
    }
    for (    PropertyEntry<Relationship> entry : data.removedRelationshipProperties()) {
      Relationship rel=entry.entity();
      Map<String,Object> propertyMap=removedRelProperties.get(rel);
      if (propertyMap == null) {
        propertyMap=new LinkedHashMap<String,Object>();
        removedRelProperties.put(rel,propertyMap);
      }
      propertyMap.put(entry.key(),entry.previouslyCommitedValue());
      if (!data.isDeleted(rel)) {
        AbstractRelationship modifiedRel=relFactory.createRelationship(securityContext,rel);
        if (modifiedRel != null) {
          changeSet.modify(modifiedRel);
          for (          StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
            hasError|=!listener.propertyRemoved(securityContext,transactionKey,errorBuffer,modifiedRel,entry.key(),entry.previouslyCommitedValue());
          }
        }
      }
    }
    for (    Node node : sortNodes(data.createdNodes())) {
      AbstractNode entity=nodeFactory.createNode(securityContext,node,true,false);
      if (entity != null) {
        hasError|=!entity.beforeCreation(securityContext,errorBuffer);
        changeSet.create(entity);
        for (        StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
          hasError|=!listener.graphObjectCreated(securityContext,transactionKey,errorBuffer,entity);
        }
      }
    }
    for (    Relationship rel : sortRelationships(data.createdRelationships())) {
      AbstractRelationship entity=relFactory.createRelationship(securityContext,rel);
      if (entity != null) {
        hasError|=!entity.beforeCreation(securityContext,errorBuffer);
        changeSet.create(entity);
        for (        StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
          hasError|=!listener.graphObjectCreated(securityContext,transactionKey,errorBuffer,entity);
        }
        try {
          AbstractNode startNode=nodeFactory.createNode(securityContext,rel.getStartNode());
          RelationshipType relationshipType=entity.getRelType();
          if (startNode != null && !data.isDeleted(rel.getStartNode())) {
            changeSet.modifyRelationshipEndpoint(startNode,relationshipType);
          }
          AbstractNode endNode=nodeFactory.createNode(securityContext,rel.getEndNode());
          if (endNode != null && !data.isDeleted(rel.getEndNode())) {
            changeSet.modifyRelationshipEndpoint(endNode,relationshipType);
          }
        }
 catch (        Throwable ignore) {
        }
      }
    }
    for (    Relationship rel : data.deletedRelationships()) {
      AbstractRelationship entity=relFactory.createRelationship(securityContext,rel);
      if (entity != null) {
        hasError|=!entity.beforeDeletion(securityContext,errorBuffer,removedRelProperties.get(rel));
        for (        StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
          hasError|=!listener.graphObjectDeleted(securityContext,transactionKey,errorBuffer,entity,removedRelProperties.get(rel));
        }
        changeSet.delete(entity);
        try {
          AbstractNode startNode=nodeFactory.createNode(securityContext,rel.getStartNode());
          RelationshipType relationshipType=entity.getRelType();
          if (startNode != null && !data.isDeleted(rel.getStartNode())) {
            changeSet.modifyRelationshipEndpoint(startNode,relationshipType);
          }
          AbstractNode endNode=nodeFactory.createNode(securityContext,rel.getEndNode());
          if (endNode != null && !data.isDeleted(rel.getEndNode())) {
            changeSet.modifyRelationshipEndpoint(endNode,relationshipType);
          }
        }
 catch (        Throwable t) {
          logger.log(Level.SEVERE,"Error while determining start/end node of deleted relationship",t);
        }
      }
    }
    for (    Node node : data.deletedNodes()) {
      logger.log(Level.FINEST,"Node deleted: {0}",node.getId());
      String type=(String)removedNodeProperties.get(node).get(AbstractNode.Key.type.name());
      AbstractNode entity=nodeFactory.createDeletedNode(securityContext,node,type);
      if (entity != null) {
        hasError|=!entity.beforeDeletion(securityContext,errorBuffer,removedNodeProperties.get(node));
        for (        StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
          hasError|=!listener.graphObjectDeleted(securityContext,transactionKey,errorBuffer,entity,removedNodeProperties.get(node));
        }
        changeSet.delete(entity);
      }
    }
    Node n=null;
    AbstractNode nodeEntity=null;
    for (    PropertyEntry<Node> entry : data.assignedNodeProperties()) {
      Node nodeFromPropertyEntry=entry.entity();
      if (!(nodeFromPropertyEntry.equals(n))) {
        nodeEntity=nodeFactory.createNode(securityContext,nodeFromPropertyEntry,true,false);
        n=nodeFromPropertyEntry;
      }
      if (nodeEntity != null) {
        String key=entry.key();
        Object value=entry.value();
        Set<PropertyValidator> validators=EntityContext.getPropertyValidators(securityContext,nodeEntity.getClass(),key);
        if (validators != null) {
          for (          PropertyValidator validator : validators) {
            hasError|=!(validator.isValid(nodeEntity,key,value,errorBuffer));
          }
        }
        for (        StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
          hasError|=!listener.propertyModified(securityContext,transactionKey,errorBuffer,nodeEntity,key,entry.previouslyCommitedValue(),value);
        }
        if (!changeSet.isNewOrDeleted(nodeEntity)) {
          indexNodeCommand.execute(nodeEntity,key);
          changeSet.modify(nodeEntity);
        }
      }
    }
    Relationship r=null;
    AbstractRelationship relEntity=null;
    for (    PropertyEntry<Relationship> entry : data.assignedRelationshipProperties()) {
      Relationship relFromPropertyEntry=entry.entity();
      if (!(relFromPropertyEntry.equals(r))) {
        relEntity=relFactory.createRelationship(securityContext,relFromPropertyEntry);
        r=relFromPropertyEntry;
      }
      if (relEntity != null) {
        String key=entry.key();
        Object value=entry.value();
        Set<PropertyValidator> validators=EntityContext.getPropertyValidators(securityContext,relEntity.getClass(),key);
        if (validators != null) {
          for (          PropertyValidator validator : validators) {
            hasError|=!(validator.isValid(relEntity,key,value,errorBuffer));
          }
        }
        for (        StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
          hasError|=!listener.propertyModified(securityContext,transactionKey,errorBuffer,relEntity,key,entry.previouslyCommitedValue(),value);
        }
        indexRelationshipCommand.execute(relEntity,key);
        changeSet.modify(relEntity);
      }
    }
    for (    AbstractNode node : changeSet.getModifiedNodes()) {
      if (!changeSet.isNewOrDeleted(node)) {
        hasError|=!node.beforeModification(securityContext,errorBuffer);
        for (        StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
          hasError|=!listener.graphObjectModified(securityContext,transactionKey,errorBuffer,node);
        }
        indexNodeCommand.execute(node);
      }
    }
    for (    AbstractRelationship rel : changeSet.getModifiedRelationships()) {
      if (!changeSet.isNewOrDeleted(relEntity)) {
        hasError|=!rel.beforeModification(securityContext,errorBuffer);
        for (        StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
          hasError|=!listener.graphObjectModified(securityContext,transactionKey,errorBuffer,rel);
        }
        indexRelationshipCommand.execute(rel);
      }
    }
    for (    AbstractNode node : changeSet.getCreatedNodes()) {
      indexNodeCommand.execute(node);
    }
    for (    AbstractRelationship rel : changeSet.getCreatedRelationships()) {
      indexRelationshipCommand.execute(rel);
    }
    if (hasError) {
      for (      StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
        listener.rollback(securityContext,transactionKey);
      }
      throw new FrameworkException(422,errorBuffer);
    }
    for (    StructrTransactionListener listener : EntityContext.getTransactionListeners()) {
      listener.commit(securityContext,transactionKey);
    }
    globalChangeSet.get().include(changeSet);
  }
 catch (  FrameworkException fex) {
    exceptionMap.put(transactionKey,fex);
    throw new IllegalStateException("Rollback");
  }
  return transactionKey;
}
