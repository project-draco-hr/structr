{
  Thread t=Thread.currentThread();
  if (!transactionKeyMap.containsKey(t)) {
    return -1L;
  }
  long transactionKey=transactionKeyMap.get(Thread.currentThread());
  if (!Services.isReady(NodeService.class)) {
    logger.log(Level.WARNING,"Node service is not ready yet.");
    return transactionKey;
  }
  SecurityContext securityContext=securityContextMap.get(Thread.currentThread());
  Command indexNodeCommand=Services.command(securityContext,IndexNodeCommand.class);
  Command indexRelationshipCommand=Services.command(securityContext,IndexRelationshipCommand.class);
  try {
    ErrorBuffer errorBuffer=new ErrorBuffer();
    boolean hasError=false;
    Map<Node,Map<String,Object>> removedNodeProperties=new LinkedHashMap<Node,Map<String,Object>>();
    Map<Relationship,Map<String,Object>> removedRelProperties=new LinkedHashMap<Relationship,Map<String,Object>>();
    NodeFactory nodeFactory=new NodeFactory(securityContext);
    RelationshipFactory relFactory=new RelationshipFactory(securityContext);
    Set<AbstractNode> modifiedNodes=new LinkedHashSet<AbstractNode>();
    Set<AbstractNode> createdNodes=new LinkedHashSet<AbstractNode>();
    Set<AbstractRelationship> modifiedRels=new LinkedHashSet<AbstractRelationship>();
    Set<AbstractRelationship> createdRels=new LinkedHashSet<AbstractRelationship>();
    begin(securityContext,transactionKey,errorBuffer);
    for (    PropertyEntry<Node> entry : data.removedNodeProperties()) {
      Node node=entry.entity();
      Map<String,Object> propertyMap=removedNodeProperties.get(node);
      if (propertyMap == null) {
        propertyMap=new LinkedHashMap<String,Object>();
        removedNodeProperties.put(node,propertyMap);
      }
      propertyMap.put(entry.key(),entry.previouslyCommitedValue());
      if (!data.isDeleted(node)) {
        modifiedNodes.add(nodeFactory.createNode(securityContext,node));
      }
    }
    for (    PropertyEntry<Relationship> entry : data.removedRelationshipProperties()) {
      Relationship rel=entry.entity();
      Map<String,Object> propertyMap=removedRelProperties.get(rel);
      if (propertyMap == null) {
        propertyMap=new LinkedHashMap<String,Object>();
        removedRelProperties.put(rel,propertyMap);
      }
      propertyMap.put(entry.key(),entry.previouslyCommitedValue());
      if (!data.isDeleted(rel)) {
        modifiedRels.add(relFactory.createRelationship(securityContext,rel));
      }
    }
    for (    Node node : data.createdNodes()) {
      AbstractNode entity=nodeFactory.createNode(securityContext,node);
      hasError|=graphObjectCreated(securityContext,transactionKey,errorBuffer,entity);
      createdNodes.add(entity);
    }
    for (    Relationship rel : data.createdRelationships()) {
      AbstractRelationship relationship=relFactory.createRelationship(securityContext,rel);
      hasError|=graphObjectCreated(securityContext,transactionKey,errorBuffer,relationship);
      createdRels.add(relationship);
    }
    for (    Relationship rel : data.deletedRelationships()) {
      AbstractRelationship relationship=relFactory.createRelationship(securityContext,rel);
      hasError|=graphObjectDeleted(securityContext,transactionKey,errorBuffer,relationship,removedRelProperties.get(rel));
    }
    for (    Node node : data.deletedNodes()) {
      hasError|=graphObjectDeleted(securityContext,transactionKey,errorBuffer,null,removedNodeProperties.get(node));
    }
    for (    PropertyEntry<Node> entry : data.assignedNodeProperties()) {
      AbstractNode entity=nodeFactory.createNode(securityContext,entry.entity());
      String key=entry.key();
      Object value=entry.value();
      Set<PropertyValidator> validators=EntityContext.getPropertyValidators(securityContext,entity.getClass(),key);
      if (validators != null) {
        for (        PropertyValidator validator : validators) {
          hasError|=!(validator.isValid(entity,key,value,errorBuffer));
        }
      }
      hasError|=propertyModified(securityContext,transactionKey,errorBuffer,entity,key,entry.previouslyCommitedValue(),value);
      indexNodeCommand.execute(entity,key);
      modifiedNodes.add(entity);
    }
    for (    PropertyEntry<Relationship> entry : data.assignedRelationshipProperties()) {
      AbstractRelationship entity=relFactory.createRelationship(securityContext,entry.entity());
      String key=entry.key();
      Object value=entry.value();
      Set<PropertyValidator> validators=EntityContext.getPropertyValidators(securityContext,entity.getClass(),key);
      if (validators != null) {
        for (        PropertyValidator validator : validators) {
          hasError|=!(validator.isValid(entity,key,value,errorBuffer));
        }
      }
      hasError|=propertyModified(securityContext,transactionKey,errorBuffer,entity,key,entry.previouslyCommitedValue(),value);
      indexRelationshipCommand.execute(entity,key);
      modifiedRels.add(entity);
    }
    for (    AbstractNode node : modifiedNodes) {
      if (!createdNodes.contains(node)) {
        hasError|=graphObjectModified(securityContext,transactionKey,errorBuffer,node);
      }
 else {
        indexNodeCommand.execute(node);
      }
    }
    for (    AbstractRelationship rel : modifiedRels) {
      if (!createdRels.contains(rel)) {
        hasError|=graphObjectModified(securityContext,transactionKey,errorBuffer,rel);
      }
 else {
        indexRelationshipCommand.execute(rel);
      }
    }
    for (    AbstractNode node : createdNodes) {
      indexNodeCommand.execute(node);
    }
    for (    AbstractRelationship rel : createdRels) {
      indexRelationshipCommand.execute(rel);
    }
    hasError|=commit(securityContext,transactionKey,errorBuffer);
    if (hasError) {
      throw new FrameworkException(422,errorBuffer);
    }
  }
 catch (  FrameworkException fex) {
    exceptionMap.put(transactionKey,fex);
    throw new IllegalStateException("Rollback");
  }
  return transactionKey;
}
