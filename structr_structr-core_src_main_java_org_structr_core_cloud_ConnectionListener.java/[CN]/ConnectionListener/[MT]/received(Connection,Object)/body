{
  logger.log(Level.FINEST,"Received {0} ({1})",new Object[]{object,object.getClass().getName()});
  if (transactionFinished && object instanceof KeepAlive) {
    logger.log(Level.FINE,"Received first KeepAlive after transaction finished, closing connection.");
    connection.close();
  }
 else   if (object instanceof Integer) {
    Integer controlSignal=(Integer)object;
    if (CloudService.BEGIN_TRANSACTION.equals(controlSignal)) {
      linkNode=true;
    }
 else     if (CloudService.END_TRANSACTION.equals(controlSignal)) {
      logger.log(Level.INFO,"Received END_TRANSACTION signal, waiting for KeepAlive to close connection.");
      idMap.clear();
      transactionFinished=true;
    }
 else     if (CloudService.CLOSE_TRANSACTION.equals(controlSignal)) {
      logger.log(Level.INFO,"Received CLOSE_TRANSACTION signal, closing connection..");
      connection.close();
      handlePullRequests();
    }
    connection.sendTCP(CloudService.ACK_DATA);
  }
 else   if (object instanceof AuthenticationContainer) {
    AuthenticationContainer auth=(AuthenticationContainer)object;
    logger.log(Level.INFO,"Received authentication container, user {0}",auth.getUserName());
    targetUser=(User)Services.command(FindUserCommand.class).execute(auth.getUserName());
    if (targetUser == null) {
      logger.log(Level.WARNING,"User not found, disconnecting");
      connection.sendTCP("Authentication failed");
      connection.close();
    }
 else {
      connection.sendTCP(auth);
      EncryptionContext.setPassword(connection.getID(),targetUser.getEncryptedPassword());
    }
  }
 else   if (object instanceof PullNodeRequestContainer) {
    pullRequests.add((PullNodeRequestContainer)object);
  }
 else   if (object instanceof PushNodeRequestContainer) {
    PushNodeRequestContainer request=(PushNodeRequestContainer)object;
    rootNode=(AbstractNode)Services.command(FindNodeCommand.class).execute(new SuperUser(),request.getTargetNodeId());
    connection.sendTCP(CloudService.ACK_DATA);
  }
 else   if (object instanceof FileNodeDataContainer) {
    final FileNodeDataContainer container=(FileNodeDataContainer)object;
    fileMap.put(container.sourceNodeId,container);
    estimatedSize+=container.getFileSize();
    connection.sendTCP(CloudService.ACK_DATA);
  }
 else   if (object instanceof FileNodeEndChunk) {
    final FileNodeEndChunk endChunk=(FileNodeEndChunk)object;
    final FileNodeDataContainer container=fileMap.get(endChunk.getContainerId());
    if (container == null) {
      logger.log(Level.WARNING,"Received file end chunk for ID {0} without file, this should not happen!",endChunk.getContainerId());
    }
 else {
      container.flushAndCloseTemporaryFile();
      Command transactionCommand=Services.command(TransactionCommand.class);
      transactionCommand.execute(new StructrTransaction(){
        @Override public Object execute() throws Throwable {
          storeNode(container,linkNode);
          return null;
        }
      }
);
    }
    connection.sendTCP(CloudService.ACK_DATA);
  }
 else   if (object instanceof FileNodeChunk) {
    final FileNodeChunk chunk=(FileNodeChunk)object;
    FileNodeDataContainer container=fileMap.get(chunk.getContainerId());
    if (container == null) {
      logger.log(Level.WARNING,"Received file chunk for ID {0} without file, this should not happen!",chunk.getContainerId());
    }
 else {
      container.addChunk(chunk);
    }
    connection.sendTCP(chunk.getSequenceNumber());
  }
 else   if (object instanceof NodeDataContainer) {
    final NodeDataContainer receivedNodeData=(NodeDataContainer)object;
    Command transactionCommand=Services.command(TransactionCommand.class);
    transactionCommand.execute(new StructrTransaction(){
      @Override public Object execute() throws Throwable {
        storeNode(receivedNodeData,linkNode);
        return null;
      }
    }
);
    connection.sendTCP(CloudService.ACK_DATA);
  }
 else   if (object instanceof RelationshipDataContainer) {
    final RelationshipDataContainer receivedRelationshipData=(RelationshipDataContainer)object;
    Command transactionCommand=Services.command(TransactionCommand.class);
    transactionCommand.execute(new StructrTransaction(){
      @Override public Object execute() throws Throwable {
        storeRelationship(receivedRelationshipData);
        return null;
      }
    }
);
    connection.sendTCP(CloudService.ACK_DATA);
  }
}
