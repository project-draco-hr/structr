{
  final GraphDatabaseService graphDb=(GraphDatabaseService)arguments.get("graphDb");
  final RelationshipFactory relFactory=(RelationshipFactory)arguments.get("relationshipFactory");
  if (!((parameters != null) && (parameters.length == 1) && (parameters[0] instanceof Map)&& !((Map)parameters[0]).isEmpty())) {
    throw new IllegalArgumentException("This command requires one argument of type Map. Map must not be empty.");
  }
  Map map=(Map)parameters[0];
  final String sourceKey=(String)map.get("sourceKey");
  final String destKey=(String)map.get("destKey");
  if (sourceKey == null || destKey == null) {
    throw new IllegalArgumentException("This command requires one argument of type Map. Map must contain values for 'sourceKey' and 'destKey'.");
  }
  if (graphDb != null) {
    final Command transactionCommand=Services.command(securityContext,TransactionCommand.class);
    transactionCommand.execute(new BatchTransaction(){
      @Override public Object execute(      Transaction tx) throws FrameworkException {
        List<AbstractRelationship> rels=(List<AbstractRelationship>)relFactory.createRelationships(securityContext,GlobalGraphOperations.at(graphDb).getAllRelationships());
        long n=0;
        for (        AbstractRelationship rel : rels) {
          if (rel.getStringProperty(AbstractNode.uuid) != null) {
            rel.setProperty(new Property(destKey),rel.getProperty(new Property(sourceKey)));
            if (n > 1000 && n % 1000 == 0) {
              logger.log(Level.INFO,"Set properties on {0} rels, committing results to database.",n);
              tx.success();
              tx.finish();
              tx=graphDb.beginTx();
              logger.log(Level.FINE,"######## committed ########",n);
            }
            n++;
          }
        }
        logger.log(Level.INFO,"Finished setting properties on {0} nodes",n);
        return null;
      }
    }
);
  }
  return null;
}
