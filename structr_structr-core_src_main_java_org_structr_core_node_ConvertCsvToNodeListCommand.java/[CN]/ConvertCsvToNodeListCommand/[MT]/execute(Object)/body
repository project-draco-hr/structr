{
  if (parameters == null || parameters.length < 2) {
    throw new UnsupportedArgumentError("Wrong number of arguments");
  }
  Long csvNodeId=null;
  AbstractNode sourceNode=null;
  Class targetClass=null;
  CsvFile csvFileNode=null;
  String filePath=null;
  User user=null;
  for (  Object o : parameters) {
    if (o instanceof CsvFile) {
      csvFileNode=(CsvFile)o;
      filePath=Services.getFilesPath() + "/" + csvFileNode.getRelativeFilePath();
    }
    if (o instanceof Long) {
      csvNodeId=(Long)o;
      sourceNode=(AbstractNode)Services.command(securityContext,FindNodeCommand.class).execute(new SuperUser(),csvNodeId);
      if (sourceNode instanceof CsvFile) {
        csvFileNode=(CsvFile)sourceNode;
        filePath=Services.getFilesPath() + "/" + csvFileNode.getRelativeFilePath();
      }
    }
    if (o instanceof Class) {
      targetClass=(Class)o;
    }
    if (o instanceof User) {
      user=(User)o;
    }
  }
  try {
    CSVReader reader=new CSVReader(new FileReader(filePath),'|','\"');
    String[] keys=reader.readNext();
    Field[] fields=targetClass.getFields();
    Map<Integer,String> fieldIndex=new HashMap<Integer,String>();
    AbstractNode o=(AbstractNode)targetClass.newInstance();
    int col=0;
    for (    String key : keys) {
      for (      Field f : fields) {
        String fieldName=(String)f.get(o);
        if (fieldName.toUpperCase().equals(key.toUpperCase())) {
          fieldIndex.put(col,fieldName);
        }
      }
      col++;
    }
    for (    Entry<Integer,String> entry : fieldIndex.entrySet()) {
      Integer i=entry.getKey();
      String v=entry.getValue();
      System.out.println("v: " + v + ", i: "+ i);
    }
    final User userCopy=user;
    final AbstractNode sourceNodeCopy=csvFileNode;
    final Command transactionCommand=Services.command(securityContext,TransactionCommand.class);
    final Command createNode=Services.command(securityContext,CreateNodeCommand.class);
    final Command createRel=Services.command(securityContext,CreateRelationshipCommand.class);
    final NodeList<AbstractNode> nodeListNode=(NodeList<AbstractNode>)transactionCommand.execute(new StructrTransaction(){
      @Override public Object execute() throws Throwable {
        NodeList<AbstractNode> result=(NodeList)createNode.execute(userCopy,new NodeAttribute(AbstractNode.Key.type.name(),NodeList.class.getSimpleName()),new NodeAttribute(AbstractNode.Key.name.name(),sourceNodeCopy.getName() + " List"));
        createRel.execute(sourceNodeCopy,result,RelType.HAS_CHILD);
        return result;
      }
    }
);
    final List<List<NodeAttribute>> creationList=new LinkedList<List<NodeAttribute>>();
    String targetClassName=targetClass.getSimpleName();
    String[] line=null;
    do {
      try {
        line=reader.readNext();
      }
 catch (      Throwable t) {
      }
      if (line != null) {
        List<NodeAttribute> nodeAttributes=new LinkedList<NodeAttribute>();
        nodeAttributes.add(new NodeAttribute(AbstractNode.Key.type.name(),targetClassName));
        for (int i=0; i < col; i++) {
          String csvValue=line[i];
          String key=fieldIndex.get(i);
          nodeAttributes.add(new NodeAttribute(key,csvValue));
        }
        creationList.add(nodeAttributes);
      }
    }
 while (line != null);
    reader.close();
    transactionCommand.execute(new StructrTransaction(){
      @Override public Object execute() throws Throwable {
        List<AbstractNode> nodesToAdd=new LinkedList<AbstractNode>();
        for (        List<NodeAttribute> attrList : creationList) {
          nodesToAdd.add((AbstractNode)createNode.execute(attrList,false));
        }
        nodeListNode.addAll(nodesToAdd);
        return (null);
      }
    }
);
    return nodeListNode;
  }
 catch (  Throwable t) {
    t.printStackTrace(System.out);
  }
  return null;
}
