{
  GraphDatabaseService graphDb=(GraphDatabaseService)arguments.get("graphDb");
  final Node node=graphDb.getNodeById(structrNode.getId());
  final Command transactionCommand=Services.command(securityContext,TransactionCommand.class);
  AbstractNode newParentNode=(AbstractNode)transactionCommand.execute(new StructrTransaction(){
    @Override public Object execute() throws Throwable {
      AbstractNode newParentNode=null;
      Command findNode=Services.command(securityContext,FindNodeCommand.class);
      if (parentNode == null) {
        if (recursive) {
          Relationship parentRel=node.getSingleRelationship(RelType.HAS_CHILD,Direction.INCOMING);
          if (parentRel != null) {
            newParentNode=(AbstractNode)findNode.execute(parentRel.getStartNode().getId());
            parentRel.delete();
          }
          for (          Path p : Traversal.description().breadthFirst().relationships(RelType.HAS_CHILD,Direction.OUTGOING).traverse(node)) {
            Node n=p.endNode();
            for (            Relationship l : n.getRelationships(Direction.OUTGOING)) {
              try {
                l.delete();
              }
 catch (              IllegalStateException ise) {
                logger.log(Level.WARNING,"Relationship {0} already deleted in this transaction",l.getId());
              }
            }
            for (            Relationship l : n.getRelationships(Direction.INCOMING)) {
              try {
                l.delete();
              }
 catch (              IllegalStateException ise) {
                logger.log(Level.WARNING,"Relationship {0} already deleted in this transaction",l.getId());
              }
            }
            try {
              ((AbstractNode)findNode.execute(n.getId())).onNodeDeletion();
            }
 catch (            Throwable t) {
              logger.log(Level.WARNING,"Exception while calling onDeletion callback: {0}",t);
            }
            n.delete();
          }
        }
 else {
          if (structrNode.hasChildren()) {
            setExitCode(Command.exitCode.FAILURE);
            setErrorMessage("Could not delete node " + node.getId() + " because it has still child nodes");
            logger.log(Level.WARNING,getErrorMessage());
            return null;
          }
          Relationship parentRel=node.getSingleRelationship(RelType.HAS_CHILD,Direction.INCOMING);
          if (parentRel != null) {
            newParentNode=structrNode.getParentNode();
            parentRel.delete();
          }
          List<StructrRelationship> incomingRels=structrNode.getIncomingRelationships();
          for (          StructrRelationship r : incomingRels) {
            r.getRelationship().delete();
          }
          try {
            structrNode.onNodeDeletion();
          }
 catch (          Throwable t) {
            logger.log(Level.WARNING,"Exception while calling onDeletion callback: {0}",t);
          }
          node.delete();
        }
      }
 else {
        for (        Relationship r : node.getRelationships(RelType.LINK,Direction.INCOMING)) {
          AbstractNode p=(AbstractNode)findNode.execute(r.getStartNode().getId());
          if (p.equals(parentNode)) {
            r.delete();
          }
        }
        newParentNode=parentNode;
        return newParentNode;
      }
      return newParentNode;
    }
  }
);
  return newParentNode;
}
