{
  Command deleteCommand=Services.command(securityContext,DeleteNodeCommand.class);
  List<AbstractNode> toDelete=new LinkedList<AbstractNode>();
  AbstractNode newParentNode=currentNode;
  for (  String param : parameters) {
    if (".".equals(param)) {
      stdOut.append("Cannot delete current node");
    }
 else {
      Object findNodeResult=Services.command(securityContext,FindNodeCommand.class).execute(currentNode,param);
      if (findNodeResult != null) {
        if (findNodeResult instanceof Collection) {
          toDelete.addAll((Collection)findNodeResult);
        }
 else         if (findNodeResult instanceof AbstractNode) {
          toDelete.add((AbstractNode)findNodeResult);
        }
      }
      for (      AbstractNode node : toDelete) {
        try {
          deleteCommand.execute(node,currentNode,recursive,securityContext.getUser());
          if (deleteCommand.getExitCode().equals(Command.exitCode.FAILURE)) {
            stdOut.append(deleteCommand.getErrorMessage());
          }
        }
 catch (        Throwable t) {
          stdOut.append(t.getMessage());
        }
      }
    }
  }
  if (newParentNode != null) {
    for (    Callback callback : callbacks)     callback.callback(newParentNode.getId());
    return (true);
  }
  return (false);
}
