{
  List<SearchAttribute> attrs=new LinkedList<SearchAttribute>();
  if (source != null) {
    attrs.add(Search.andExactProperty(propertyKey,source.toString()));
  }
  List<AbstractNode> nodes=(List<AbstractNode>)Services.command(securityContext,SearchNodeCommand.class).execute(null,false,false,attrs);
  int resultCount=nodes.size();
switch (resultCount) {
case 0:
    if ((source != null) && createIfNotExisting) {
      AbstractNode newNode=(AbstractNode)Services.command(securityContext,CreateNodeCommand.class).execute(new NodeAttribute(AbstractNode.Key.type.name(),type.getSimpleName()),new NodeAttribute(propertyKey.name(),source.toString()));
      if (newNode != null) {
        return newNode;
      }
 else {
        logger.log(Level.WARNING,"Unable to create node of type {0} for property {1}",new Object[]{type.getSimpleName(),propertyKey.name()});
      }
    }
  break;
case 1:
AbstractNode node=nodes.get(0);
if (!type.isAssignableFrom(node.getClass())) {
throw new FrameworkException("base",new TypeToken(propertyKey.name(),type.getSimpleName()));
}
return node;
}
if (source != null) {
Map<String,Object> attributes=new LinkedHashMap<String,Object>();
attributes.put(propertyKey.name(),source.toString());
attributes.put("type",type.getSimpleName());
throw new FrameworkException(type.getSimpleName(),new PropertiesNotFoundToken("base",attributes));
}
return null;
}
