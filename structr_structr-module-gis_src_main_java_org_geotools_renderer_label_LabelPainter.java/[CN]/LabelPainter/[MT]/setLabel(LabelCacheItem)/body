{
  this.labelItem=labelItem;
  labelItem.getTextStyle().setLabel(labelItem.getLabel());
  labelBounds=null;
  lines=null;
  String text=labelItem.getLabel();
  if (!(text.contains("\n") || labelItem.getAutoWrap() > 0) || labelItem.isFollowLineEnabled()) {
    FontRenderContext frc=graphics.getFontRenderContext();
    TextLayout layout=new TextLayout(text,labelItem.getTextStyle().getFont(),frc);
    LineInfo line=new LineInfo(text,layoutSentence(text,labelItem),layout);
    labelBounds=line.gv.getVisualBounds();
    normalizeBounds(labelBounds);
    lines=Collections.singletonList(line);
    return;
  }
  String[] splitted=text.split("\\n");
  lines=new ArrayList<LineInfo>();
  if (labelItem.getAutoWrap() <= 0) {
    for (    String line : splitted) {
      FontRenderContext frc=graphics.getFontRenderContext();
      TextLayout layout=new TextLayout(line,labelItem.getTextStyle().getFont(),frc);
      LineInfo info=new LineInfo(line,layoutSentence(line,labelItem),layout);
      lines.add(info);
    }
  }
 else {
    Map<TextAttribute,Object> map=new HashMap<TextAttribute,Object>();
    map.put(TextAttribute.FONT,labelItem.getTextStyle().getFont());
    for (int i=0; i < splitted.length; i++) {
      String line=splitted[i];
      AttributedString attributed=new AttributedString(line,map);
      AttributedCharacterIterator iter=attributed.getIterator();
      LineBreakMeasurer lineMeasurer=new LineBreakMeasurer(iter,BreakIterator.getWordInstance(),graphics.getFontRenderContext());
      BreakIterator breaks=BreakIterator.getWordInstance();
      breaks.setText(line);
      int prevPosition=0;
      while (lineMeasurer.getPosition() < iter.getEndIndex()) {
        TextLayout layout=lineMeasurer.nextLayout(labelItem.getAutoWrap(),line.length(),true);
        int newPosition=prevPosition;
        if (layout != null) {
          newPosition=lineMeasurer.getPosition();
        }
 else {
          int nextBoundary=breaks.following(prevPosition);
          if (nextBoundary == BreakIterator.DONE) {
            newPosition=line.length();
          }
 else {
            newPosition=nextBoundary;
          }
          AttributedCharacterIterator subIter=attributed.getIterator(null,prevPosition,newPosition);
          layout=new TextLayout(subIter,graphics.getFontRenderContext());
          lineMeasurer.setPosition(newPosition);
        }
        String extracted=line.substring(prevPosition,newPosition).trim();
        if (!"".equals(extracted)) {
          LineInfo info=new LineInfo(extracted,layoutSentence(extracted,labelItem),layout);
          lines.add(info);
        }
        prevPosition=newPosition;
      }
    }
  }
  double maxWidth=0;
  for (  LineInfo line : lines) {
    maxWidth=Math.max(line.gv.getVisualBounds().getWidth(),maxWidth);
  }
  double boundsY=0;
  double labelY=0;
  for (  LineInfo info : lines) {
    Rectangle2D currBounds=info.gv.getVisualBounds();
    TextLayout layout=info.layout;
    double minX=(maxWidth - currBounds.getWidth()) * labelItem.getTextStyle().getAnchorX() - currBounds.getMinX();
    info.x=minX;
    if (labelBounds == null) {
      labelBounds=currBounds;
      boundsY=currBounds.getMinY() + layout.getAscent() + layout.getDescent()+ layout.getLeading();
    }
 else {
      Rectangle2D translated=new Rectangle2D.Double(minX,boundsY,currBounds.getWidth(),currBounds.getHeight());
      boundsY+=layout.getAscent() + layout.getDescent() + layout.getLeading();
      labelY+=layout.getAscent() + layout.getDescent() + layout.getLeading();
      labelBounds=labelBounds.createUnion(translated);
    }
    info.y=labelY;
  }
  normalizeBounds(labelBounds);
}
